input {
  # Filebeat input for application logs
  beats {
    port => 5044
  }
  
  # Direct input for application logs
  file {
    path => "/app/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    tags => ["application"]
  }
  
  # Nginx access logs
  file {
    path => "/var/log/nginx/access.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["nginx", "access"]
  }
  
  # Nginx error logs
  file {
    path => "/var/log/nginx/error.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["nginx", "error"]
  }
  
  # Docker container logs
  docker {
    host => "unix:///var/run/docker.sock"
    tags => ["docker"]
  }
}

filter {
  # Parse application logs (JSON format)
  if "application" in [tags] {
    json {
      source => "message"
    }
    
    # Add timestamp if not present
    if ![timestamp] {
      mutate {
        add_field => { "timestamp" => "%{@timestamp}" }
      }
    }
    
    # Parse log level
    if [level] {
      mutate {
        uppercase => [ "level" ]
      }
    }
    
    # Extract calculator type from message
    if [message] =~ /calculator/ {
      grok {
        match => { "message" => "calculator.*?(?<calculator_type>[a-zA-Z-]+)" }
      }
    }
    
    # Extract user ID if present
    if [message] =~ /user/ {
      grok {
        match => { "message" => "user.*?(?<user_id>[a-zA-Z0-9-]+)" }
      }
    }
  }
  
  # Parse Nginx access logs
  if "nginx" in [tags] and "access" in [tags] {
    grok {
      match => { 
        "message" => "%{NGINXACCESS}"
      }
    }
    
    # Parse response time
    if [request_time] {
      mutate {
        convert => { "request_time" => "float" }
      }
    }
    
    # Parse status code
    if [response] {
      mutate {
        convert => { "response" => "integer" }
      }
    }
    
    # Categorize status codes
    if [response] >= 200 and [response] < 300 {
      mutate {
        add_field => { "status_category" => "success" }
      }
    } else if [response] >= 300 and [response] < 400 {
      mutate {
        add_field => { "status_category" => "redirect" }
      }
    } else if [response] >= 400 and [response] < 500 {
      mutate {
        add_field => { "status_category" => "client_error" }
      }
    } else if [response] >= 500 {
      mutate {
        add_field => { "status_category" => "server_error" }
      }
    }
    
    # Extract calculator type from request path
    if [request] =~ /calculator/ {
      grok {
        match => { "request" => ".*calculator/(?<calculator_type>[a-zA-Z-]+)" }
      }
    }
    
    # GeoIP lookup for client IP
    geoip {
      source => "clientip"
      target => "geoip"
    }
  }
  
  # Parse Nginx error logs
  if "nginx" in [tags] and "error" in [tags] {
    grok {
      match => { 
        "message" => "(?<timestamp>%{YEAR}[./-]%{MONTHNUM}[./-]%{MONTHDAY}[- ]%{TIME}) \[%{LOGLEVEL:severity}\] %{POSINT:pid}#%{NUMBER:tid}: (\*%{NUMBER:connection_id} )?%{GREEDYDATA:message}"
      }
      overwrite => [ "message" ]
    }
    
    # Parse timestamp
    date {
      match => [ "timestamp", "yyyy/MM/dd HH:mm:ss" ]
    }
  }
  
  # Parse Docker container logs
  if "docker" in [tags] {
    # Extract container information
    if [docker][container][name] {
      mutate {
        add_field => { "container_name" => "%{[docker][container][name]}" }
      }
    }
    
    if [docker][container][image] {
      mutate {
        add_field => { "container_image" => "%{[docker][container][image]}" }
      }
    }
    
    # Parse JSON logs from application containers
    if [container_name] =~ /laser-calc/ {
      json {
        source => "message"
      }
    }
  }
  
  # Add common fields
  mutate {
    add_field => { 
      "environment" => "${ENVIRONMENT:production}"
      "service" => "laser-calc"
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "agent", "ecs", "input", "log" ]
  }
  
  # Handle parsing failures
  if "_grokparsefailure" in [tags] {
    mutate {
      add_field => { "parse_error" => "grok_parse_failure" }
    }
  }
  
  if "_jsonparsefailure" in [tags] {
    mutate {
      add_field => { "parse_error" => "json_parse_failure" }
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "laser-calc-logs-%{+YYYY.MM.dd}"
    template_name => "laser-calc"
    template => "/usr/share/logstash/templates/laser-calc-template.json"
    template_overwrite => true
  }
  
  # Debug output (remove in production)
  if "${DEBUG_LOGS:false}" == "true" {
    stdout {
      codec => rubydebug
    }
  }
  
  # Output errors to separate index
  if [level] == "ERROR" or [severity] == "error" or [status_category] == "server_error" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "laser-calc-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Output security events to separate index
  if [tags] and "security" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "laser-calc-security-%{+YYYY.MM.dd}"
    }
  }
  
  # Output performance metrics
  if [request_time] and [request_time] > 2.0 {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "laser-calc-performance-%{+YYYY.MM.dd}"
    }
  }
}
